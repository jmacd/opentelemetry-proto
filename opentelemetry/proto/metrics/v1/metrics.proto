// Copyright 2019, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package opentelemetry.proto.metrics.v1;

import "opentelemetry/proto/common/v1/common.proto";
import "opentelemetry/proto/resource/v1/resource.proto";

option java_multiple_files = true;
option java_package = "io.opentelemetry.proto.metrics.v1";
option java_outer_classname = "MetricsProto";
option go_package = "github.com/jmacd/opentelemetry-proto/gen/go/metrics/v1";

// A collection of InstrumentationLibraryMetrics from a Resource.
message ResourceMetrics {
  // The resource for the metrics in this message.
  // If this field is not set then no resource info is known.
  opentelemetry.proto.resource.v1.Resource resource = 1;

  // A list of metrics that originate from a resource.
  repeated InstrumentationLibraryMetrics instrumentation_library_metrics = 2;
}

// A collection of Metrics produced by an InstrumentationLibrary.
message InstrumentationLibraryMetrics {
  // The instrumentation library information for the metrics in this message.
  // If this field is not set then no library info is known.
  opentelemetry.proto.common.v1.InstrumentationLibrary instrumentation_library = 1;

  // A list of metrics that originate from an instrumentation library.
  repeated Metric metrics = 2;
}

// Metric contains one or more timeseries.
//
// The data model and relation between entities is shown in the diagram below.
//
// - Metric is composed of a MetricDescriptor and a list of data points.
// - MetricDescriptor contains a name, description, unit, kind, and value type.
// - Points is a list of DataPoints (shown vertically).
// - DataPoint contains timestamps, labels, and one of the value type fields.
//
//     Metric
//  +----------+         +------------------------+
//  |descriptor|-------->| MetricDescriptor       |
//  |          |         | name                   |
//  |          |         | description            |
//  |          |         | unit                   |
//  |    points|--+      | kind                   |
//  +----------+  |      | value type             |
//                |      +------------------------+
//                |
//                |      +---------------------------+
//                |      |DataPoint 1                |
//                v      |+------+------+   +------+ |
//             +-----+   ||label |label |...|label | |
//             |  1  |-->||value1|value2|...|valueN| |
//             +-----+   |+------+------+   +------+ |
//             |  .  |   |+-----+                    |
//             |  .  |   ||value|                    |
//             |  .  |   |+-----+                    |
//             |  .  |   +---------------------------+
//             |  .  |                   .
//             |  .  |                   .
//             |  .  |                   .
//             |  .  |   +---------------------------+
//             |  .  |   |DataPoint M                |
//             +-----+   |+------+------+   +------+ |
//             |  M  |-->||label |label |...|label | |
//             +-----+   ||value1|value2|...|valueN| |
//                       |+------+------+   +------+ |
//                       |+-----+                    |
//                       ||value|                    |
//                       |+-----+                    |
//                       +---------------------------+
//
//-----------------------------------------------------------------------
// DataPoint is a general type that includes three common fields:
// - Labels are the optional key-value pairs associated with the data point.
// - StartTimeUnixNano MUST be set to the start of the interval when the
//   descriptor kind includes CUMULATIVE or DELTA.  This field is not set
//   for INSTANTANEOUS timeseries, where instead the TimeUnixNano field is
//   set for individual points.
// - TimeUnixNano MUST be set to:
//   - the end of the interval (CUMULATIVE or DELTA)
//   - the instantaneous time of the event (INSTANTANEOUS).
//
// DataPoint values are strongly typed: each DataPoint uses a specific field
// depending on the value type of the metric.  The scalar value types
// (SCALAR_INT64, SCALAR_DOUBLE) use fields of the DataPoint directly, while
// there are currently 3 DataPoint sub-messages (Histogram, Summary, RawValue).
message Metric {
  // Descriptor describes the Metric.
  MetricDescriptor descriptor = 1;

  // Points is a list of one or more DataPoints for a single metric.
  repeated DataPoint points = 2;
}

// Defines a metric type and its schema.
message MetricDescriptor {
  // Name of the metric, including its DNS name prefix. It must be unique.
  string name = 1;

  // Description of the metric, which can be used in documentation.
  string description = 2;

  // Unit in which the metric value is reported. Follows the format
  // described by http://unitsofmeasure.org/ucum.html.
  string unit = 3;

  // ValueType is the type of values a metric has.  ValueType determines
  // which field of the DataPoint will be used for Metrics with this
  // descriptor.
  enum ValueType {
    // INVALID_TYPE is the default ValueType, it MUST not be used.
    INVALID_VALUE_TYPE = 0;

    // Note that int64 ValueTypes use the even numbers and double
    // ValueTypes use the odd numbers.

    // ScalarInt64 implies that Metric.Points MUST use DataPoint.value_int64.
    SCALAR_INT64     = 2;
    // ScalarDouble implies that Metric.Points MUST use DataPoint.value_double.
    SCALAR_DOUBLE    = 3;

    // HistogramInt64 implies that Metric.Points MUST use
    // DataPoint.histogram with int64 boundaries.
    HISTOGRAM_INT64  = 4;
    // HistogramDouble implies that Metric.Points MUST use
    // DataPoint.histogram with floating point boundaries.
    HISTOGRAM_DOUBLE = 5;

    // SummaryInt64 implies that Metric.Points MUST use DataPoint.summary
    // with int64 min/max/sum/last/count values.
    SUMMARY_INT64    = 6;
    // SummaryDouble implies that Metric.Points MUST use
    // DataPoint.summary with double min/max/sum/last/count values.
    SUMMARY_DOUBLE   = 7;

    // RawInt64 implies that Metric.Points MUST use DataPoint.raw with
    // int64 values.
    RAW_INT64        = 8;
    // RawDouble implies that Metric.Points MUST use DataPoint.raw with
    // double value.
    RAW_DOUBLE       = 9;
  }

  // ValueType is the type of values this metric has.
  ValueType value_type = 4;

  // KindElement contains a set of bit masks used to construct Kind enum values.
  // There are 7 bits used presently, broken into groups:
  //
  //   Temporality is the temporal quality values of a metric have. It
  //   describes how those values relate to the time interval over
  //   which they are reported.  One of the 3 Temporality values
  //   (CUMULATIVE, DELTA, INSTANTANEOUS) MUST be set.
  //
  //   Structure indicates whether metric data describes a sum of
  //   measurements (ADDING) or a collection of individual
  //   measurements (GROUPING).  Value types may be interpreted
  //   differently depending on Structure.  For example, a Histogram
  //   DataPoint may be computed for a Counter (ADDING) instrument
  //   or a ValueRecorder (GROUPING) instrument, and:
  //
  //   - ADDING Histograms define a meaningful Sum in the form of a
  //     distribution of constituent measurements.
  //   - GROUPING Histograms define a distribution of measurements,
  //     where the sum is potentially not meaningful.  If also
  //     SYNCHRONOUS, these data points define a rate in terms of
  //     their Count.
  //
  //   Monotonicity applies only to ADDING data points.  When set,
  //   MONOTONIC indicates that the calculated sum can be monitored as
  //   a rate of change.  Observers of MONOTONIC metrics should never
  //   see the value decrease without a reset (i.e., StartTimeUnixNano
  //   advances), otherwise a decreasing MONOTONIC metric suggests an
  //   SDK bug.
  //
  //   Synchronicity applies to data points produced when the
  //   application called the API, as opposed to the SDK calling the
  //   application via a callback.  When set, SYNCHRONOUS indicates
  //   that there may be an associated trace context.  The rate of
  //   synchronous events has a meaningful interpretation, when
  //   considering the DataPoint.Histogram.Count or
  //   DataPoint.Summary.Count fields, as these are true
  //   application-level events.
  //
  //   Data points without SYNCHRONOUS are considered asynchronous.
  //   The DataPoint.Histogram.Count and DataPoint.Summary.Count
  //   fields record a number of observations, which is controlled
  //   both by the number of distinct label sets observed and by the
  //   rate of collection.  Because asynchronous metric Count fields
  //   depend on the rate of collection, the rate of these metrics
  //   should not be interpreted as rates (however these Counts may
  //   still be used to form an average value of these metrics).
  enum KindElement {
    // INVALID_KIND_MASK is not used.
    INVALID_KIND_MASK = 0;

    // One of the following three MUST be set. There are 3 exclusive Temporality kinds.

    // INSTANTANEOUS is a metric whose values are measured at a particular
    // instant. The values are not aggregated over any time interval and are
    // unique per timestamp. As such, these metrics are not expected to have
    // an associated start time.
    INSTANTANEOUS = 0x1;

    // DELTA is a metric whose values are the aggregation of measurements
    // made over a time interval. Successive metrics contain aggregation of
    // values from continuous and non-overlapping intervals.
    //
    // The values for a DELTA metric are based only on the time interval
    // associated with one measurement cycle. There is no dependency on
    // previous measurements like is the case for CUMULATIVE metrics.
    //
    // For example, consider a system measuring the number of requests that
    // it receives and reports the sum of these requests every second as a
    // DELTA metric:
    //
    //   1. The system starts receiving at time=t_0.
    //   2. A request is received, the system measures 1 request.
    //   3. A request is received, the system measures 1 request.
    //   4. A request is received, the system measures 1 request.
    //   5. The 1 second collection cycle ends. A metric is exported for the
    //      number of requests received over the interval of time t_0 to
    //      t_0+1 with a value of 3.
    //   6. A request is received, the system measures 1 request.
    //   7. A request is received, the system measures 1 request.
    //   8. The 1 second collection cycle ends. A metric is exported for the
    //      number of requests received over the interval of time t_0+1 to
    //      t_0+2 with a value of 2.
    DELTA = 0x4;

    // CUMULATIVE is a metric whose values are the aggregation of
    // successively made measurements from a fixed start time until the last
    // reported measurement. This means that current values of a CUMULATIVE
    // metric depend on all previous measurements since the start time.
    // Because of this, the sender is required to retain this state in some
    // form. If this state is lost or invalidated, the CUMULATIVE metric
    // values MUST be reset and a new fixed start time following the last
    // reported measurement time sent MUST be used.
    //
    // For example, consider a system measuring the number of requests that
    // it receives and reports the sum of these requests every second as a
    // CUMULATIVE metric:
    //
    //   1. The system starts receiving at time=t_0.
    //   2. A request is received, the system measures 1 request.
    //   3. A request is received, the system measures 1 request.
    //   4. A request is received, the system measures 1 request.
    //   5. The 1 second collection cycle ends. A metric is exported for the
    //      number of requests received over the interval of time t_0 to
    //      t_0+1 with a value of 3.
    //   6. A request is received, the system measures 1 request.
    //   7. A request is received, the system measures 1 request.
    //   8. The 1 second collection cycle ends. A metric is exported for the
    //      number of requests received over the interval of time t_0 to
    //      t_0+2 with a value of 5.
    //   9. The system experiences a fault and loses state.
    //   10. The system recovers and resumes receiving at time=t_1.
    //   11. A request is received, the system measures 1 request.
    //   12. The 1 second collection cycle ends. A metric is exported for the
    //      number of requests received over the interval of time t_1 to
    //      t_0+1 with a value of 1.
    CUMULATIVE = 0x2;

    // One of the following two MUST be set. There are 2 exclusive
    // Structure kinds.  Structure defines how the data 

    // GROUPING structure means the value has been computed by combining
    // individual values in a meaningful aggregation.  GROUPING structure
    // implies the sum of
    GROUPING = 0x8;

    // ADDING structure means the measurement determines a sum.  For
    // DELTA kind this is expressed as the change in sum since the
    // last collection.  For CUMULATIVE kind this is express as last
    // collected value of the sum.
    ADDING = 0x10;

    // MONOTONIC may be set in conjunction with ADDING kinds, implying
    // that the sum determines a meaningful rate.  For DELTA kind,
    // this implies non-negative value series.  For CUMULATIVE kind,
    // this implies a non-decreasing value series.
    MONOTONIC = 0x20;

    // SYNCHRONOUS may be set for any kind of metric, indicating it was generated
    // through synchronous events in which the application calls the API.  If
    // SYNCHRONOUS is not set, it implies the event originated in a callback
    // where the SDK called the application.
    SYNCHRONOUS = 0x40;
  }

  // Kind explains how the DataPoint was produced (Structure), how
  // the point was aggregated with resepect to time (Temporality), and
  // whether it was computed synchronously, and when the Structure is
  // ADDING, whether the captured Sum is also monotonic.
  //
  // Kind names are generated from valid combinations of KindElement
  // by joining the effective KindElements using underscores.  There
  // are:
  //
  // - 3 possibilities for Temporality
  // - 2 possibilities for Synchronous/Asynchronous
  // - 3 possibilities for Structure/Monotonicity: Grouping, Adding
  //   Monotonic, and Adding (not monotonic)
  //
  // This makes 18 valid values.
  enum Kind {
    // INVALID_KIND is the default Kind, it MUST not be used.
    INVALID_KIND = 0;

    // The following codes are generated by a program.

    ADDING_MONOTONIC_INSTANTANEOUS_SYNCHRONOUS  = 0x71;
    ADDING_MONOTONIC_INSTANTANEOUS_ASYNCHRONOUS = 0x31;
    ADDING_MONOTONIC_CUMULATIVE_SYNCHRONOUS     = 0x72;
    ADDING_MONOTONIC_CUMULATIVE_ASYNCHRONOUS    = 0x32;
    ADDING_MONOTONIC_DELTA_SYNCHRONOUS          = 0x74;
    ADDING_MONOTONIC_DELTA_ASYNCHRONOUS         = 0x34;

    ADDING_INSTANTANEOUS_SYNCHRONOUS            = 0x51;
    ADDING_INSTANTANEOUS_ASYNCHRONOUS           = 0x11;
    ADDING_CUMULATIVE_SYNCHRONOUS               = 0x52;
    ADDING_CUMULATIVE_ASYNCHRONOUS              = 0x12;
    ADDING_DELTA_SYNCHRONOUS                    = 0x54;
    ADDING_DELTA_ASYNCHRONOUS                   = 0x14;

    GROUPING_INSTANTANEOUS_SYNCHRONOUS          = 0x49;
    GROUPING_INSTANTANEOUS_ASYNCHRONOUS         = 0x9;
    GROUPING_CUMULATIVE_SYNCHRONOUS             = 0x4a;
    GROUPING_CUMULATIVE_ASYNCHRONOUS            = 0xa;
    GROUPING_DELTA_SYNCHRONOUS                  = 0x4c;
    GROUPING_DELTA_ASYNCHRONOUS                 = 0xc;
  }

  // Kind describes properties of the Metric that are necessary to
  // interpret the data and/or describe how it was produced.
  Kind kind = 5;
}

// DataPoint is a point of raw or aggregate metric data, generally containing
// the labels, one or two timestamps, and a single value field.  The value field
// that is used is determined by the descriptor ValueType.
message DataPoint {
  // The set of labels that uniquely identify this timeseries.
  repeated opentelemetry.proto.common.v1.StringKeyValue labels = 1;

  // start_time_unix_nano is the start of the interval for which a CUMULATIVE or
  // DELTA kind of metric was computed.
  // reset.
  //
  // This field is ignored for INSTANTANEOUS metric kinds and SHOULD not be set.
  //
  // The CUMULATIVE or DELTA value is over the time interval (start_time_unix_nano, time_unix_nano].
  // Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
  //
  // TODO: Can we omit this when all metrics in a report share the same start time?
  fixed64 start_time_unix_nano = 2;

  // time_unix_nano is the end of the interval for CUMULATIVE and DELTA kinds,
  // or it is the event timestamp for INSTANTANEOUS kinds.
  //
  // TODO: Can we omit this when a non-instantaneous metric has the same end time
  // as others in the report?
  fixed64 time_unix_nano = 3;

  // A logical oneof among the following fields, as prescribed by ValueType:

  // SCALAR_INT64 uses this field.
  int64 value_int64 = 4;

  // SCALAR_DOUBLE uses this field.
  double value_double = 5;

  // HISTOGRAM_INT64 and HISTOGRAM_DOUBLE use this field.
  Histogram histogram = 6;

  // SUMMARY_INT64 and SUMMARY_DOUBLE use this field.
  Summary summary = 7;

  // RAW_INT64 and RAW_DOUBLE use this field.  Do not set "exemplars" when reporting
  // raw values, as exemplars can be computed by the receiver when in that case.
  repeated RawValue raw_values = 8;
  
  // Exemplars are set alongside value_int64, value_double, histogram,
  // and summary fields, in which case the exemplars carry additional
  // information, including the full label set, exact timestamp,
  // optional trace context, and sample count associated with selected
  // events.
  repeated RawValue exemplars = 9;
}

// Histogram is a single data point in a timeseries that describes the time-varying
// values of a Histogram. A Histogram contains summary statistics for a population of values,
// it may optionally contain the distribution of those values across a set of buckets.
message Histogram {
  // count is the number of values in the population. Must be non-negative. This value
  // must be equal to the sum of the "count" fields in buckets if a histogram is provided.
  uint64 count = 1;

  // sum of the values in the population. If count is zero then this field
  // must be zero. This value must be equal to the sum of the "sum" fields in buckets if
  // a histogram is provided.
  int64 sum_int64 = 2;
  double sum_double = 3;

  // Bucket contains values for a bucket.
  message Bucket {
    // The number of values in each bucket of the histogram, as described by
    // bucket_options.
    uint64 count = 1;
  }

  // buckets is an optional field contains the values of histogram for each bucket.
  //
  // The sum of the values in the buckets "count" field must equal the value in the count field.
  //
  // The number of elements in buckets array must be by one greater than the
  // number of elements in bucket_bounds array.
  //
  // Note: if HistogramDataPoint.bucket_options defines bucket bounds then this field
  // must also be present and number of elements in this field must be equal to the
  // number of buckets defined by bucket_options.
  repeated Bucket buckets = 6;

  // A histogram may optionally contain the distribution of the values in the population.
  // In that case one of the option fields below and "buckets" field both must be defined.
  // Otherwise all option fields and "buckets" field must be omitted in which case the
  // distribution of values in the histogram is unknown and only the total count and sum are known.

  // explicit_bounds is the only supported bucket option currently.
  // TODO: Add more bucket options.

  // explicit_bounds specifies buckets with explicitly defined bounds for values.
  // The bucket boundaries are described by "bounds" field.
  //
  // This defines size(bounds) + 1 (= N) buckets. The boundaries for bucket
  // at index i are:
  //
  // [0, bounds[i]) for i == 0
  // [bounds[i-1], bounds[i]) for 0 < i < N-1
  // [bounds[i], +infinity) for i == N-1
  // The values in bounds array must be strictly increasing and > 0.
  //
  // Note: only [a, b) intervals are currently supported for each bucket. If we decides
  // to also support (a, b] intervals we should add support for these by defining a boolean
  // value which decides what type of intervals to use.
  repeated int64 explicit_bounds_int64 = 7;
  repeated double explicit_bounds_double = 8;
}

// Summary is a single data point in a timeseries that describes the time-varying
// values of a Summary metric.
message Summary {
  // Remove the labels, start_time, and time TODO.
  //
  // fields: Add min, max, last fields
  // as described in https://github.com/open-telemetry/oteps/pull/117
  //
  // (Same comment)
  uint64 count = 1;

  // (Same comment)
  int64  sum_int64 = 2;
  double sum_double = 3;

  // MIN, MAX, LAST value
  int64  min_int64 = 4;
  double min_double = 5;

  int64  max_int64 = 6;
  double max_double = 7;

  int64  last_int64 = 8;
  double last_double = 9;

  // (Similar comments)
  message ValueAtQuantile {
    double quantile = 1;  // [0,1], if 0 prefer MIN, if 1 prefer MAX.
    int64  value_int64 = 2;
    double value_double = 3;
  }

  // (Same comment)
  repeated ValueAtQuantile quantile_values = 10;
}

message RawValue {
  // Numerical value of the measurement that was recorded. Only one of these
  // two fields is used for the data, based on MetricDescriptor.measurement_type
  double value_double = 1;
  int64 value_int64 = 2;

  // Exact time that the measurement was recorded
  fixed64 time_unix_nano = 3;

  // Labels that were passed with the measurement, but not included in the DataPoint's labels
  repeated opentelemetry.proto.common.v1.StringKeyValue additional_labels = 4;

  // (Optional) Span ID of the current trace
  bytes span_id = 5;

  // (Optional) Trace ID of the current trace
  bytes trace_id = 6;

  // (Optional) When sample_count is non-zero, this exemplar has been chosen in a statistically
  // unbiased way such that the exemplar is representative of `sample_count` individual events
  double sample_count = 7;
}
